---
title: 如何更好地管理技术团队？
date: 2016-5-11 18:38:31
tags:
    - Management
    - Specification
categories:
    - Summary
description: 技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。
---

# 前言

## PM与TL的区别

其实一个Team Leader的职责与Project Manager相像，但Team Leader更着重于技术开发方面，通常一个大型项目都会有一两个开发团队由Team Leader带领，负责开发核心部分，而其它部分分派给不同开发小组或者分派给外包公司。在网上常看到几句话，贴切地形容了PM与TL的区别：“技术人员乐于被领导；但他们不喜欢被管理，不喜欢像牛一样被驱赶或指挥。管理者强迫人们服从他们的命令，而领导者则会带领他们一起工作。管理是客观的，没有个人感情因素，它假定被管理者没有思想和感受，被告知要做什么和该如何做。领导是引领、引导，它激励人们达成目标。领导力是带有强烈个人感情色彩的，它不是你能命令的，也不是你能测量评估和测试的。”

TL对于团队内的member，必须在技术上能够进行胜任领导，他就像黑夜里的灯塔，引导和修正member前进的航向。因此TL也必需保持照亮团队，保持对member的充分了解，并在技术领域投入持续的学习热情，向团队成员传道，补齐短板，让大家的核心战斗力一起提高。

无论是PM与TL，对业务与技术都要有深入的了解，只是PM更侧重于业务的管理，盈利的多少，风险的大小等等，而TL则侧重于项目的成本，开发的难度，软件的架构等技术方面的问题。在某些人眼中，技术与管理就像鱼与熊掌，不可兼得，但依在下看来，两者却是秤不离砣，密不可分。只要及时提升自己对技术与管理的认识，不断地向深一层发展，要从程序员提升到技术管理人员只是时间的问题。

团队规模有限时，分工很可能没这么清晰，很多时候TL和PM是同一个人在兼任，角色的模糊，可能带来职责和权利的混乱，而且个人精力也有限，仅适合任务量较小时实行。

## 技术管理与团队管理的区别

技术团队与其它的团队的区别，可能在于技术人员的管理难度。一方面因为领域之间的差异性，譬如前端技术链与后端技术链的深与广，导致熟悉前端的同时，很难对后端保持足够的了解。另一方面在领域内的差异性，典型的是多年争论C语言与Java语言的优劣，忽视了技术都有局限性，脱离了使用需求的比较没有意义。如果技术人员比较狭隘，往往无法理解对方的差异性，从而造成不必要的争议。这一点在年轻的团队中，是很突出的问题，大家普遍经验欠缺，对上下游的技术无法做到足够认知，同时因为年轻而无法接受建议，行成内耗。

技术团队管理需要划分为正切的两个方向：技术管理和团队管理。管理的目标是：提高协作时的执行力，执行效率，并约束进行规范执行。技术管理的目标是：保持并引导团队成员之间的技术协作一致性，如前端技术团队和后端技术团队。由技术负责人制定日常规范，推动规范的落地，以公有的强制约定来避免不必要的内耗。规范的含义是比较广泛的：设计规范、编码规范、安全规范、接口规范、部署规范。团队管理解决的问题是：如何持久降低团队之间或团队成员之间的合作成本？如产品团队和技术团队。除了leader的影响，往往需要合理的行政制度来作为基础。好的行政制度往往是一家公司最为重要的部分，它就像生态系统中的土壤一样重要，有了好的土壤，才可能生长出好的团队，而一个好的产品是往往需要团队来持续打磨的。

从纯粹的技术工作者转向管理者难点在于是否具备了管理能力？对与团队内的成员，是否一致的认为在你的带领下可以得到更好的发展？可以是经济利益上的或职业发展上的。对于上层决策领导是否认为你可担此大任？而领导经常不相信你已经具备管理能力，或确实缺少部分能力(可能是软实力，语言沟通能力)，这在国外很常见，管理层大多是美国人或印度人，中国人由于文化上的本位差异，很难上升到管理层。

# 技术管理

## 原则

KISS原则是英语Keep It Simple, Stupid 的首字母缩略字。KISS原则是指在设计当中应當注重简约的原则。

### 命名规范

我们在编写任何程序之前，第一件事要做的就是命名。

形如：需求文档名称，概要设计文档名称，接口文档名称，软件系统名称，功能模块名称，类名称，方法名称，参数名称...

在认识陌生人时，第一次接触往往互递名片。熟络后的沟通交流，都以名字来开始了。一个人的名字是否好记，影响会有多大？我以前公司同事丁某某，父母取名用了生僻字，导致每次登机之前需要到机场值班经理盖章，浪费很多时间。而恰巧他是一位销售人员，每周都有2~3次的飞行，你在想他为什么不去换名字？想想30多岁的人生积累，你需要多少成本改名字吧？想象不出来，问问自己换一个使用5年的手机号码成本是多大吧？

#### 重要性

命名规范竟如此重要，但大多数开发者的命名习惯往往没有你想象的那么好。除了上面提到的生僻字问题，还有很多人喜欢用拼音去命名类、函数，甚至是变量。我不知道这是英文词汇量的问题还是个人风格，但我个人非常不提倡这样做。如何优雅地为程序中的变量和函数命名？很简单，把你的变量名拎出来，问别人，你看到这个名字会想到什么，他说的和你想的一致，就用，否则就改。改到基本上不懂程序的人都能大概看懂你写的是什么，就优雅了。

为什么重要？提高可维护性。不加约束的开发者写出来的代码，就像是大家临时拼凑出来的一桌菜，你上粤菜，他上川菜。虽然都好吃，但没有人全想吃，造成的局面是，爱吃粤菜的人总是夹粤菜，爱吃川菜的就不去吃粤菜了。在代码上来讲，各自的代码风格迥异，导致理解成本加大，你负责的代码需要修改时，就只有你能改了，团队其他人很难帮得上忙，如果修改工作量比较大，这岂不是把自己逼死吗？如果结合好的代码注释和设计文档，会不会理解成本下降呢？但就算是文档写得再详细，我们也要去读代码，所以文档主要是体现思路和反映需求和设计。在程序上，我们的命令应当和文档中的术语保持一致，而程序中的命名也应该是用和文档相同的风格，这样，我们可以少很多理解上的成本。好的代码在命名上是完全可读的，代码即文档，做到这点，可以极大的提高团队内协作效率。

比较常见的有下面三种命名方式：

* 驼峰(Camel)命名法:又称小驼峰命名法，除首单词外，其余所有单词的第一个字母大写。GetOrderList
* 帕斯卡(Pascal)命名法:又称大驼峰命名法，所有单词的第一个字母大写。gtOrderList
* 蛇形(Snake)命名法:单词与单词间用下划线做间隔。get\_order\_list

一般在命名函数和变量时，多使用小驼峰；命名类名多使用大驼峰，不建议使用蛇形命名。如在命名数据库表名时，最好使用小驼峰以一致性的对应到pojo。

好的命名，还给代码审计、代码排错工作降低成本，在做code review时，如果缺失详细注释，规范化的命名使大家的理解成本降低，从而让审计工作更容易的完成。我们回过头来想，很多公司无法推动代码审计的实行，到底是什么原因在阻碍呢？还有在线上代码深层排错时，我们采用SystemTap火焰图技术来做，由于函数的名称通常会包含语义上的信息，在输出的图表中就可以轻易的按照函数名来推断问题所在，这是非常了不起的。

![](/img/flameGraph.png)

#### 如何做？

具体的施行，可以参考：[Google Java Style](http://blog.csdn.net/yzmyyff/article/details/45243261)

#### 约定优于配置

约定优于配置的目标是，团队内各成员参照约定的策略来进行开发，减少无意义的说明项，从而降低沟通成本。为降低持续学习成本和保证团队新成员快速融入，约定项不宜过多，且应该放到团队成员随意备查的地方(media wiki?)。

##### 过渡配置
Hibernate的早期版本中，将类及其属性映射到数据库上需要是在XML文件中的描述，其中大部分信息都应能够按照约定得到，如将类映射到同名的数据库表，将属性分别映射到表上的同名字段。这样的做法不仅繁琐易出错，而且可维护性低，后续的版本抛弃了XML配置文件，而是使用这些恰当的约定，对于不符合这些约定的情形，可以使用Java注解来说明。

相应的从Ant到Maven的过渡，Grunt到Gulp的过渡，也都很好的体现了这个原则的正确性。

##### 改进
约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。
本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为"products_sold"，才需写有关这个名字的配置。

### 合理的设计

合理的设计，主要是面向软件可维护性、可扩展性提出，如果能兼顾性能和安全就更好了。设计是有成本的，如果软件的生命周期在预期内就不会太长，例如很多一次性的产品：内部MIS系统，售卖给企业后，几乎不再需要任何的维护。此时设计上就可以从简，没有必要为不会来临的维护去做基础，因此设计也是需要有一定的前瞻性。

#### 适时分层

分层设计的好处主要是面向软件可维护性。合理的分层设计，往往将逻辑拆分为内聚的多层次，层之间的边界是清晰的。例如典型的三层设计，展示层、逻辑层、数据层。带来的好处是显而易见的，对于数据层来说，只需要对逻辑层提供访问数据的接口，具体如何访问数据，是访问文件还是RDBMS、NoSQL，与逻辑层是无关的。相应的重构起来也是局部重构即可，例如更换搜索引擎：Solr-->Elastic Search，只需要重构数据层的具体实现即可，上层任何代码不需要改动，这对于高复杂度的软件无疑是非常友好的。

![](/img/splitLayer.png)

那分层对与软件可扩展性的影响呢？带来了一定程度的坏影响，新加一个业务逻辑功能，可能涉及到很多层的改造，而在Maven mutilmodule模式下，很可能层之间的代码是隔离的。这意味着，新加功能的代码量会有增多。

一般来说分层设计适用于大型软件的持续构建，它依靠团队内的其它高效率手段来弥补稍低的可扩展性。它对安全和性能，并没有什么影响。

#### 避免过度设计
#### 模块化设计
模块化设计在重构时，可以将影响降到最低。达到低风险、低成本。
模块化设计对系统快速构建是一个阻碍，它要求将可预见的同类型代码复用，内聚到一个模块中。

### 前轻后重
系统之间的调用链，前置系统轻逻辑。
#### 上轻下重，核心逻辑内敛
模块之间的调用链，上层模块轻逻辑


### 基础优先
在构建软件时，保持基础组件优先稳定下来，定义好对外接口，并保留可扩展性。
例如安全性设计，在后期加比在前期加的成本高很多。

### 最小冗余
#### 代码保持最少行数
1.少一行代码，就少了一个潜在的bug
2.行数少了，往往意味着重用性高了
3.不要过度牺牲可读性


### 保持简单
#### 简单意味着快速
#### 简单意味着灵活
#### 简单意味着易扩展
#### 简单意味着易重构

### Fast fail

### 代码即文档
#### 合理的注释

### 关键业务设计宣讲
#### 保持一致的看法

### 小步快走
#### 意味着版本迭代快速
#### 意味着版本迭代稳定
#### 意味着部署回滚成本低

## 重构与优化
### 紧急优先
优先对紧急需要改进的部分进行重构
### 计划性的重构
在敏捷开发时，往往时间不够，有些模块只能以非优雅的方式构建。但是需要在这些模块加上TODO以免重构时遗忘。
### 时机
团队一致认为模块维护成本高昂时，果断重构。
### 基于成本的优化

CBO(Cost base optimize)

引用数据库查询分析计划来说明：[如果有人问你数据库的原理，叫他看这篇文章#查询优化器](http://blog.jobbole.com/100349)

### 数据支撑
给出重构前后的成本与收益报告
### 持续性
在时间不够或时机不成熟时，分阶段的进行

## 技术选型
### 开源优先
### 稳定优先
### 掌控度高优先
### 保留备选项
### 只有合适的技术，没有最好的技术。
### 避免一招鲜吃遍天
手里有锤子，看到什么都觉得像钉子
### 技术升级
系统容量与性能指标的要求，在业务发展的各个阶段是不固定的，技术需要保留一定前瞻性，不做被动跟随。

## 接口
### 版本控制
### 访问控制
访问权限的验证
### 流量控制
拒绝恶意访问
### 审查与监控
### 灰度发布
### 无状态
### 原子化
### CQRS
命令查询职责分离模式，读不强依赖写。

## 外部接口
### 合理调用
同步VS异步
批量VS单个  批量：局部失败
### 保持怀疑
#### 兜底方案
如果有可能，在外部接口调用失败时，读取本地上一次调用成功的缓存。例如：加载和更新广告，CDN访问失败进行回源。

进行兜底时，注意将失败的信息进行记录以便告警


## APP
### 远程控制权
### 展示为主
### 少的逻辑
### 适度安全

## 部署
### 监控
### 降低升级时间窗
### 没有人需要等待
正式发布后，对于任何用户都是公平使用的。不需要牺牲部分用户利益。
常见于缓存autowarm时需要阻塞第一批到达的用户。
### 提前消除隐患


# 团队管理
精细化管理
## keep watch
工作与心理的交流分享
## 保持信任
## 保持怀疑
## 持续考评
## 分享中提高


有一个著名的理论，叫木桶理论。意思是木桶能装多少水，是由木桶最短的那个板来决定的。团队也是如此。团队的力量有多大，很多时候也是由能力最差的那个成员来决定的。为了提高团队整体的实力，我们必须提高每个人的能力。我们的改善必须得是可度量的，所以我们也要数字化能力的标准。


## 提高工作效率

其实很多团队都在进行着这个工作。最常见的就是会做一些小工具，来节省我们的时间。比如代码自动生成工具，自动打包工具，自动的比较工具等等。我们应该制作尽可能多的自动化工具，来解放我们的时间。

为了让大家投入更多的热情来制作各种工具，团队可以制定一定的奖励规则，对制作工具的人给予奖励。

公司要把最好的人才放到工具开发那一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以得到提高，而不仅仅是工程师。

## 互相备份
## 互相支撑
## 向上管理
## 向下管理
### 了解队员的擅长与不足
### 合理的任务分配
### 适度挑战性的任务
### 给出完成任务需要的资源
### 激励中成长
眼前利益与发展前景
### 给出职业发展的机会
### 公开与公平中考评
### 保持团队稳定
团队成员的诉求：团队，产品，薪资，发展。

团队提供集体成长的氛围环境。

令人兴奋的产品，提供持续打磨的动力。

合适的薪资，使个人不过多为生活所扰。

良好的发展前景，对个人的职业生涯带来腾飞。

“穷得只剩钱”。小公司对企业文化不慎重视，开发团队的整体风气也没要求，招人过来只求出活，对团队个人发展是零投入的态度。这样的企业要想招到人、留住人，只剩钱了，但个人发展到一定高度，往往企业再也给不出足够的钱，这时再想留住人就很难了。这就是企业只依靠薪资吸引人带来的问题，对其他人才诉求不重视，穷得只剩钱。

当收入待遇和地位与自身才能不匹配时候，离开几乎是个必然的选择。

## 适时剔除不合格
## 技术梯队
不同层次的人员配比，完成不同类型的任务。注意人员的上升下降渠道。


# Reference

* [以Facebook为案例剖析科技公司应有的工具文化](http://blogread.cn/it/article/7346?f=wb&utm_source=top.caibaojian.com/102758)
* [动态追踪技术（中） - Dtrace、SystemTap、火焰图](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712266&idx=1&sn=54d909d240eb701ae48467dc798ddc7f&scene=2&srcid=0506gUskHi8qJi6joV2483uM&from=timeline&isappinstalled=0#wechat_redirect)
* [极限编程](https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B)